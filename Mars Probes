import java.util.*;
import java.io.*;
import java.text.*;

public class Elo7
{
    // Esse exercício requer que, dada a área de um planalto marciano a ser explorado, cujos limites vão de (0,0)
    // a (colMax, linMax), todas as sondas de exploração (de número desconhecido) tenham suas instruções
    // interpretadas e executadas. Ao final da série de instruções de cada sonda, deverá ser devolvido um sinal
    // de resposta que inclui as coordenadas do ponto ocupado pela sonda e sua direção final.
    
    // OBS: Eu fiz esse exercício da forma que estou acostumado a resolver os problemas de sites como 
    // o URI Online Judge e desafios de lógica fornecidos nas maratonas de programação. Há diversas formas de
    // resolver problemas assim, mas eu gosto de usar essa classe customizada chamada Reader, pois com ela eu
    // perco menos tempo com processos de entrada-saída - já que Time Limit Exceeded pode ser um grande empecilho
    // em Java.
    
    public static void main(String[] args) throws IOException {
        Reader.init(System.in, true);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        int linMax = Reader.nextInt(), colMax = Reader.nextInt(), i;
        char instruction;
        String commands;
        
        // Esses dois dicionários abaixo são utilizados para fazer a conversão de direções cardinais para
        // inteiros (para facilitar sua manipulação) e vice-versa, na ocasião de impressão da saída
        
        HashMap<String, Integer> compassToInt = new HashMap<String, Integer>(){{
            put("N", 0); put("E", 1); put("S", 2); put("W", 3);        
        }};
        
        HashMap<Integer, String> intToCompass = new HashMap<Integer, String>(){{
            put(0, "N"); put(1, "E"); put(2, "S"); put(3,"W");        
        }};                
        
        // O laço principal abaixo foi projetado para realizar repetidamente o conjunto de operações sempre
        // que houver uma nova sonda cujas instruções serão processadas. A condição EOF (end of file) indica
        // que não há mais sondas e o programa libera o buffer de saída na tela do monitor
        
        while (!Reader.isEOF()) {            
            Sonda.zeraVariaveis();
            Sonda.setX(Reader.nextInt());
            Sonda.setY(Reader.nextInt());            
            Sonda.setDirecao(compassToInt.get(Reader.next()));            
            
            commands = Reader.nextLine();
            for (i = 0; i < commands.length(); i++) {
                instruction = commands.charAt(i);
                if (instruction == 'L') {
                    Sonda.viraSentidoAntihorario();
                } else if (instruction == 'R') {
                    Sonda.viraSentidoHorario();  
                } else {
                    if (Sonda.getDirecao() == 0 && Sonda.getY() < linMax)                                          
                        Sonda.moveNorte();
                    else if (Sonda.getDirecao() == 1 && Sonda.getX() < colMax)
                        Sonda.moveLeste();
                    else if (Sonda.getDirecao() == 2 && Sonda.getY() > 0)
                        Sonda.moveSul();
                    else if (Sonda.getDirecao() == 3 && Sonda.getX() > 0)
                        Sonda.moveOeste();
                    else 
                        // Condição em que alguma instrução ultrapassa o limite da área a ser explorada
                        out.write(String.format
                        ("Instrução no. %d, %c: Região planetária inválida!\n", i+1, instruction));
                }
            }
            out.write(String.format("%d %d %s\n", 
                      Sonda.getX(), Sonda.getY(), intToCompass.get(Sonda.getDirecao())));
        }
        out.flush();
    }
}
class Sonda {
    // Fiz uma nova classe Sonda, que maneja todas as variáveis e métodos relacionados à movimentação da sonda
    // no território marciano. Assim, para manipular a sonda é necessário acessar os membros e métodos desta 
    // classe, sendo o acesso vedado a qualquer outra parte do programa.
    
    private static int x, y, direcao;       
    
    // O método que inicia as variáveis da sonda com zeros, antes de sua utilização.
    
    static void zeraVariaveis() {
        x = y = direcao = 0;
    }
    
    // Os três métodos que direcionam os valores da entrada às variáveis respectivas.
    
    static void setX(int n) {
        x = n;
    }
    static void setY (int n) {
        y = n;
    }
    static void setDirecao (int d) {
        direcao = d;
    }
    
    // Os métodos responsáveis pela alteração das coordenadas da sonda no momento atual.
    
    static void moveNorte() {
        y++;
    }
    static void moveSul() {
        y--;
    }
    static void moveLeste() {
        x++;
    }
    static void moveOeste() {
        x--;
    }    
    
    // Os métodos que alternam a orientação da sonda no sentido horário ou antihorário, de acordo com as 
    // instruções 'R' ou 'L', respectivamente.
    
    static void viraSentidoAntihorario () {
        direcao = (direcao - 1) % 4;
        if (direcao < 0) direcao += 4;
    }
    static void viraSentidoHorario () {
        direcao = (direcao + 1) % 4;                
    }
    
    // Os três métodos que retornam os valores apontados pelas variáveis x (eixo das abscissas), y (eixo das
    // ordenadas) e direcao (orientação da sonda), em um dado momento.
    
    static int getDirecao() {
        return direcao;
    }
    static int getX() {
        return x;
    }
    static int getY() {
        return y;
    }
}
 class Reader{
    private static BufferedReader reader;
    private static StringTokenizer tokenizer;
    private static boolean isWhileEOF;
    private static String line;
    
    static void init(InputStream input, boolean whileEOF){
        reader = new BufferedReader(new InputStreamReader(input));
        tokenizer = new StringTokenizer("");
        isWhileEOF = whileEOF;
    }
    
    static boolean isEOF() throws IOException{
        line = reader.readLine();
        return !(line != null);
    }
    
    static String next() throws IOException{
        while(! tokenizer.hasMoreTokens()){
            if(isWhileEOF && line != null){
                tokenizer = new StringTokenizer(line);
                line = null;
            }
            else
                tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }
    
    static String nextLine() throws IOException{
        if(isWhileEOF && line != null){
            String str = line;
            line = null;
            return str;
        }
        return reader.readLine();
    }
    
    static int nextInt() throws IOException{return Integer.parseInt(next());}
}
